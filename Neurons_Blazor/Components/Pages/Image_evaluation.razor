@page "/image_evaluation"
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Text.Json.Serialization
@using System.Linq
@using Neurons_Types
@using System.Net.Http.Headers
@using System.Net.Http.Json
@using MudBlazor

<MudGrid Spacing="3">
    <!-- Image Upload -->
    <MudItem xs="12" md="4">
        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">Upload Picture</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudFileUpload T="IBrowserFile"
                               FilesChanged="OnImageFileChanged"
                               Accept="image/*"
                               MaxFiles="1">
                    <ActivatorContent>
                        <MudFab Color="Color.Secondary"
                                StartIcon="@Icons.Material.Filled.Image"
                                Label="Load picture" />
                    </ActivatorContent>
                </MudFileUpload>
            </MudCardContent>
        </MudCard>
    </MudItem>

    <!-- PDF Upload - "MudItem xs="12" md="4" is what determines size -->
    <MudItem xs="12" md="4">
        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">Upload Brand Kit (PDF)</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudFileUpload T="IBrowserFile"
                               FilesChanged="OnBrandKitFileChanged"
                               Accept="application/pdf"
                               MaxFiles="1">
                    <ActivatorContent>
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.CloudUpload">
                            Upload PDF
                        </MudButton>
                    </ActivatorContent>
                </MudFileUpload>
            </MudCardContent>
        </MudCard>
    </MudItem>

    <!-- Multi-select -->
    <MudItem xs="12" md="4">
        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">Select LLM</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudSelect T="string"
                           MultiSelection="true"
                           SelectAll="true"
                           SelectAllText="Select all felines"
                           @bind-SelectedValues="options"
                           MultiSelectionTextFunc="@(new Func<List<string>, string>(GetMultiSelectionText))"
                           Label="LLM"
                           AdornmentIcon="@Icons.Material.Filled.Search">
                    @foreach (var model in models)
                    {
                        <MudSelectItem T="string" Value="@model">@model</MudSelectItem>
                    }
                </MudSelect>
            </MudCardContent>
        </MudCard>
    </MudItem>
</MudGrid>

@if (imagePreview != null)
{
    <div class="mt-3">
        <img src="@imagePreview" style="max-width: 300px;" />
    </div>
}

<div class="mt-3">
    <button class="btn btn-primary" @onclick="CallImageEvaluation" disabled="@(!CanEvaluate || isLoading)">
        @(isLoading ? "Evaluating..." : "Evaluate Brand Compliance")
    </button>
</div>

@if (!string.IsNullOrEmpty(error))
{
    <p class="text-danger mt-3">@error</p>
}

@if (evalResponse is not null)
{
    <div class="mt-4">
        <h4>Prompt Used</h4>
        <pre>@evalResponse.PromptUsed</pre>

        <h4>Model Output</h4>
        <pre>@evalResponse.ModelOutput</pre>
    </div>
}

@code {
    private IBrowserFile? uploadedImage;
    private IBrowserFile? uploadedBrandKit;
    private string? imagePreview;
    private bool isLoading;
    private string? error;

    private ImageEvaluationResponse? evalResponse;

    [Inject] private HttpClient Http { get; set; } = default!;

    private bool CanEvaluate => uploadedImage is not null && uploadedBrandKit is not null;

    // Dropdown
    private string value { get; set; } = "Nothing selected";
    private IEnumerable<string> options { get; set; } = new HashSet<string> { "ChatGPT-4o" };
    private string[] models = { "Jaguar", "Leopard", "ChatGPT-4o", "Lynx", "Panther", "Puma", "Tiger" };

    private string GetMultiSelectionText(List<string> selectedValues)
        => $"{string.Join(", ", selectedValues)} has been selected!";

    // ---------- MudFileUpload handlers ----------
    private async Task OnImageFileChanged(IBrowserFile file)
    {
        uploadedImage = file;
        var resized = await file.RequestImageFileAsync("image/png", 600, 500);
        using var stream = resized.OpenReadStream(10 * 1024 * 1024);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        imagePreview = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
    }

    private Task OnBrandKitFileChanged(IBrowserFile file)
    {
        uploadedBrandKit = file;
        return Task.CompletedTask;
    }

    // Shared preview builder
    private async Task BuildImagePreviewAsync(IBrowserFile? file)
    {
        if (file is null) { imagePreview = null; return; }

        var resizedImage = await file.RequestImageFileAsync("image/png", 600, 500);
        using var stream = resizedImage.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        imagePreview = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
    }

    private async Task CallImageEvaluation()
    {
        if (!CanEvaluate) return;

        error = null;
        evalResponse = null;
        isLoading = true;

        try
        {
            // Prepare image bytes
            var resizedImage = await uploadedImage!.RequestImageFileAsync("image/png", 600, 500);
            byte[] imageBytes;
            using (var s = resizedImage.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024))
            using (var ms = new MemoryStream())
            {
                await s.CopyToAsync(ms);
                imageBytes = ms.ToArray();
            }

            // Prepare PDF stream
            using var pdfStream = uploadedBrandKit!.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);

            // Build multipart content
            using var form = new MultipartFormDataContent();

            var pdfContent = new StreamContent(pdfStream);
            pdfContent.Headers.ContentType = new MediaTypeHeaderValue("application/pdf");
            form.Add(pdfContent, "brand_kit", uploadedBrandKit.Name);

            var imgContent = new ByteArrayContent(imageBytes);
            imgContent.Headers.ContentType = new MediaTypeHeaderValue("image/png");
            form.Add(imgContent, "image_file", uploadedImage.Name);

            // Call FastAPI endpoint
            var response = await Http.PostAsync("http://127.0.0.1:8000/evaluate_brand_compliance_wAPI", form);
            var body = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
            {
                error = $"Upload failed: {(int)response.StatusCode} {response.ReasonPhrase}\n{body}";
                return;
            }

            // Deserialize API response
            evalResponse = JsonSerializer.Deserialize<ImageEvaluationResponse>(
                body,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (evalResponse == null)
                error = "Could not parse API response.";
        }
        catch (Exception ex)
        {
            error = $"An error occurred: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }
}
