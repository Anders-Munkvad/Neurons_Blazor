@page "/image_evaluation"
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Text.Json.Serialization;
@using System.Linq
@rendermode InteractiveServer

<div class="upload-box">
    <h3>Upload an Advertisement Image</h3>
    <InputFile OnChange="HandleImageSelected" accept="image/*" />
</div>

<div class="upload-box">
    <h3>Upload a brand compliance information</h3>
    <InputFile OnChange="HandleBrandCompliance" accept="application/pdf" />
</div>

@if (imagePreview != null)
{
    <div class="mt-3">
        <img src="@imagePreview" style="max-width: 300px;" />
    </div>
}

@if (isLoading)
{
    <p>Checking brand complianceâ€¦</p>
}

@if (!string.IsNullOrEmpty(error))
{
    <p class="text-danger">@error</p>
}

@if (brandResponse != null)
{
    <div class="mt-3">
        <h4>@brandResponse.Message</h4>

        @if (brandResponse.Requirements.FontStyles is not null)
        {
            <h5>Font styles</h5>
            <ul>
            @foreach (var kv in brandResponse.Requirements.FontStyles)
            {
                <li><b>@kv.Key:</b> @kv.Value</li>
            }
            </ul>
        }

        @if (brandResponse.Requirements.LogoSafezone is not null)
        {
            <h5>Logo safe zone</h5>
            <p><b>Value:</b> @brandResponse.Requirements.LogoSafezone.Value</p>
            <p>@brandResponse.Requirements.LogoSafezone.Requirements</p>
        }

        @if (brandResponse.Requirements.LogoColour?.LogoColours is not null)
        {
            <h5>Logo colours</h5>
            <ul>
            @foreach (var c in brandResponse.Requirements.LogoColour.LogoColours)
            { <li>@c</li> }
            </ul>
        }

        @if (brandResponse.Requirements.LogoColourPalette?.Colours is not null)
        {
            <h5>Colour palette</h5>
            <ul>
            @foreach (var c in brandResponse.Requirements.LogoColourPalette.Colours)
            { <li>@c</li> }
            </ul>
        }
    </div>
}


@code {
    // Class - maybe make a class module. Probably a good idea

    public class BrandComplianceResponse
    {
        public ComplianceRequirements Requirements { get; set; } = new();
        public string Message { get; set; } = "";
    }

    public class ComplianceRequirements
    {
        [JsonPropertyName("font_styles")]
        public Dictionary<string, string>? FontStyles { get; set; }

        [JsonPropertyName("logo_safezone")]
        public LogoSafezone? LogoSafezone { get; set; }

        [JsonPropertyName("logo_colour")]
        public LogoColour? LogoColour { get; set; }

        [JsonPropertyName("logo_colour_palette")]
        public LogoColourPalette? LogoColourPalette { get; set; }
    }

    public class LogoSafezone
    {
        public string? Value { get; set; }
        public string? Requirements { get; set; }
    }

    public class LogoColour
    {
        [JsonPropertyName("Logo colours")]
        public List<string>? LogoColours { get; set; }
    }

    public class LogoColourPalette
    {
        public List<string>? Colours { get; set; }
    }


    private BrandComplianceResponse? brandResponse;

    private IBrowserFile? selectedFile;
    private string? imagePreview;
    private bool isLoading;           // <-- was missing
    private string? error;            // <-- was missing

    [Inject]
    private HttpClient Http { get; set; } = default!; // Injected via DI

    private async Task HandleImageSelected(InputFileChangeEventArgs e)
    {
        selectedFile = e.File;

        if (selectedFile != null)
        {
            // Optional: resize to avoid large preview memory usage
            var resizedImage = await selectedFile.RequestImageFileAsync("image/png", 600, 500);

            using var stream = resizedImage.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB max
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var imageBytes = ms.ToArray();
            imagePreview = $"data:image/png;base64,{Convert.ToBase64String(imageBytes)}";
        }
    }

    private async Task HandleBrandCompliance(InputFileChangeEventArgs e)
    {
        error = null;
        brandResponse = null;
        isLoading = true;

        try
        {
            var file = e.File;
            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
            using var content = new MultipartFormDataContent();
            var fileContent = new StreamContent(stream);
            fileContent.Headers.ContentType =
                new System.Net.Http.Headers.MediaTypeHeaderValue("application/pdf");

            // field name must match what your API expects (e.g., "file")
            content.Add(fileContent, "file", file.Name);

            var response = await Http.PostAsync("http://127.0.0.1:8000/extract_brand_compliance", content);
            var body = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"Status: {(int)response.StatusCode} {response.ReasonPhrase}");
            Console.WriteLine($"Body: {body}");

            if (response.IsSuccessStatusCode)
            {
                brandResponse = JsonSerializer.Deserialize<BrandComplianceResponse>(
                    body, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                if (brandResponse == null)
                    error = "Could not parse API response.";
            }
            else
            {
                error = $"Upload failed: {(int)response.StatusCode} {response.ReasonPhrase}\n{body}";
            }
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }
}
